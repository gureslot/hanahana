<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>リール配列確認</title>

<style>
body{
  margin:0;
  font-family:sans-serif;
  background:#fff;
  color:#111;
}

.wrap{
  max-width:1100px;
  margin:40px auto;
  padding:0 20px;
  text-align:center;
}

h1{
  font-size:40px;
  margin:0 0 10px 0;
  letter-spacing:1px;
}

.desc{
  margin:0 0 30px 0;
  font-size:16px;
  color:#555;
}

.reel-wrapper{
  display:flex;
  gap:2px;
  justify-content:center;
  align-items:flex-start;
}

.reel{
  width:clamp(90px, 9vw, 120px);
  overflow:hidden;
  touch-action:none;
  user-select:none;
  -webkit-user-drag:none;
}

.track{
  will-change:transform;
}

.track img{
  display:block;
  width:100%;
  height:auto;
  user-select:none;
  -webkit-user-drag:none;
  pointer-events:none;
}

.nav{
  display:flex;
  gap:20px;
  justify-content:center;
  flex-wrap:wrap;
  margin:40px 0 0 0;
}

.nav a{
  display:inline-block;
  padding:14px 28px;
  border:2px solid #ff2a6d;
  color:#111;
  text-decoration:none;
  border-radius:10px;
  transition:0.2s;
  font-size:18px;
  font-weight:bold;
}

.nav a:hover{
  background:#ff2a6d;
  color:#fff;
}

.copyright{
  margin:40px 0 20px 0;
  font-size:13px;
  color:#777;
}

@media(max-width:768px){
  h1{ font-size:30px; }
}
</style>
</head>

<body>

<div class="wrap">

  <h1>リール配列確認</h1>
  <p class="desc">ドラッグすると図柄を動かせます。</p>

  <div class="reel-wrapper">
    <div class="reel" data-src="../assets/reel_1_strip_21x33.png"></div>
    <div class="reel" data-src="../assets/reel_2_strip_21x33.png"></div>
    <div class="reel" data-src="../assets/reel_3_strip_21x33.png"></div>
  </div>

  <div class="nav">
    <a href="../index.html">index</a>
    <a href="../uchikata.html">ハナハナ打ち方紹介</a>
  </div>

  <div class="copyright">
    ©PIONEER CO.,LTD.
  </div>

</div>

<script>
const CELLS = 21;
const VIEW_CELLS = 42;

function mod(n, m){
  return ((n % m) + m) % m;
}

document.querySelectorAll('.reel').forEach(reel=>{

  const src = reel.dataset.src;

  const track = document.createElement('div');
  track.className = 'track';
  reel.appendChild(track);

  let dragging = false;
  let startY = 0;
  let baseOffset = 0;
  let liveOffset = 0;

  let stripH = 0;
  let cellH = 0;
  let viewH = 0;
  let ready = false;

  function apply(offset){
    track.style.transform = `translateY(${-offset}px)`;
  }

  function buildCopies(){
    const copies = Math.ceil((viewH + stripH) / stripH);
    track.innerHTML = '';
    for(let i=0; i<copies; i++){
      const img = new Image();
      img.src = src;
      track.appendChild(img);
    }
  }

  function measureAndInit(img){
    stripH = img.getBoundingClientRect().height;
    cellH  = stripH / CELLS;
    viewH  = cellH * VIEW_CELLS;

    reel.style.height = `${viewH}px`;

    buildCopies();

    baseOffset = 0;
    liveOffset = 0;
    apply(0);

    ready = true;
  }

  const probe = new Image();
  probe.src = src;
  probe.onload = ()=>{
    track.innerHTML = '';
    track.appendChild(probe);

    requestAnimationFrame(()=>{
      measureAndInit(probe);
    });
  };

  reel.addEventListener('pointerdown', e=>{
    if(!ready) return;
    dragging = true;
    startY = e.clientY;
    liveOffset = baseOffset;
    reel.setPointerCapture(e.pointerId);
  });

  reel.addEventListener('pointermove', e=>{
    if(!ready) return;
    if(!dragging) return;

    const dy = e.clientY - startY;
    const raw = baseOffset + (-dy);

    liveOffset = mod(raw, stripH);
    apply(liveOffset);
  });

  function endDrag(){
    if(!ready) return;
    if(!dragging) return;

    dragging = false;

    const snapped = Math.round(liveOffset / cellH) * cellH;
    baseOffset = mod(snapped, stripH);
    apply(baseOffset);
  }

  reel.addEventListener('pointerup', endDrag);
  reel.addEventListener('pointercancel', endDrag);

  window.addEventListener('resize', ()=>{
    if(!ready) return;

    const firstImg = track.querySelector('img');
    if(!firstImg) return;

    const tmp = new Image();
    tmp.src = src;
    tmp.onload = ()=>{
      track.innerHTML = '';
      track.appendChild(tmp);

      requestAnimationFrame(()=>{
        const keepIndex = Math.round(baseOffset / cellH);

        measureAndInit(tmp);

        baseOffset = mod(keepIndex * cellH, stripH);
        liveOffset = baseOffset;
        apply(baseOffset);
      });
    };
  });

});
</script>

</body>
</html>
